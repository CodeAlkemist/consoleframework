1. Описание работы XAML

XAML обрабатывается следующим образом. Парсер проходит все элементы подряд, и превращает их в объекты.
Экземпляр объекта создаётся при встрече элемента (атрибута). Далее, если это атрибут, то его значение
присваивается свойству описываемого объекта сразу, а если это вложенный элемент, то его содержимое будет
создано рекурсивно из того, что внутри этого элемента. Присваивание конструируемого объекта свойству
вышестоящего объекта происходит в момент завершения парсинга описания его содержимого, то есть при нахождении
парного закрывающего тега. В этот момент объект полностью сконфигурирован вместе со всеми вложенными объектами.

2. Система Content-свойств аналогична используемой в WPF.

3. Как происходит преобразование типов и как обрабатываются коллекции.

Преобразование типов производится только встроенное - из строк в числа, перечисления и некоторые встроенные
конвертеры для структур (Point, Size, Thickness).
Если нужно использовать кастомный конвертер, его нужно вызвать с помощью расширения разметки.
(пока еще не готово).

Поддерживаются любые коллекции, реализующие ICollection<T> или IDictionary<string, T>.
Если при обработке закрывающего тега выясняется, что свойство вышестоящего элемента (свойство, которое мы
определяем текущим объектом) реализует ICollection<T>, то текущий сконфигурированный объект будет добавлен
в эту коллекцию вызовом Add(T obj) - вместо стандартного поиска конвертера и последующего вызова сеттера.
Таким образом, для коллекций сеттер не нужен - нужен только геттер.
Аналогично обрабатываются свойства типа IDictionary<string, T>. Пример:

<Window.Resources>
	<item x:Key="1">Строка</item>
	<item x:Key="2">Строка 2</item>
</Window.Resources>

Во время обработки тега первого закрывающего тега </item> значение "Строка" будет добавлено в коллекцию
Window.Resources.

Причём перед тем, как вызвать метод Add (это справедливо и для коллекций, и для словарей) будет произведена
проверка на совместимость типа текущего сконфигурированного объекта и T-типа-аргумента коллекции/словаря.
Если типы не совместимы, будет выполнена попытка поиска соответствующего конвертера.

4. По поводу пространств имён - если нужно использовать x:Key, то в рутовом элементе XML обязательно должна 
быть ссылка на соответствующее пространство имён:

<Window xmlns:x="http://consoleframework.org/xaml.xsd">
</Window>

5. Создание объектов произвольного типа и указание аргументов конструктора.

Обычные объекты, создаваемые в XAML, требуют наличия конструктора по умолчанию. Если необходимо создать
экземпляр класса, у которого нет конструктора по умолчанию, можно создать factory-класс и сделать это
с помощью него. Но есть и встроенный класс ObjectFactory, который умеет создавать объекты любого типа,
вызывать конструктор с определёнными аргументами и наполнять его свойства значениями, аналогично тому,
как это бы работало, если бы мы создавали этот объект в XAML напрямую. Например, у нас есть класс

class TestClass<T>
{
    public TestClass( int intProperty ) {
        IntProperty = intProperty;
    }

    public int IntProperty { get; set; }

    public string StringProperty { get; set; }

    public T TProperty { get; set; }
}

С помощью ObjectFactory создать его экземпляр в XAML можно следующим образом:

<object TypeName="ConsoleFramework.Xaml.TestClass`1[System.String]">
    <int x:Key="1">66</int>
    <string x:Key="IntProperty">55</string>
</object>

Устанавливая x:Key в число, мы говорим фабрике, что это - аргумент конструктора (с соответствующим индексом).
Если же x:Key не является числом, то x:Key интерпретируется как название свойства.
При определении значений аргументов конструкторов и свойств можно использовать все обычно доступные в этом
контексте инструменты - задание текстом или расширением разметки, или опять же с помощью расширения разметки
получить ссылку на ранее созданный объект по x:Id.

Работает это так: создавая экземпляр ObjectFactory, мы заполняем его Content-свойство, которое является
Dictionary<string, object>. Но после завершения конфигурирования этот объект заменяется тем, который мы
в нём описываем. Механика аналогична тому, как работают "примитивы" <string>, <int> и так далее, более того,
они все реализуют интерфейс IFactory, который позволяет подменять объект на другой (определяемой логикой
фабрики) в момент завершения разбора завершающего тега.

6. Ссылки на другие объекты с помощью расширения разметки Ref.