Как работает подсистема, управляющая фокусом элементов управления.

Задача управления фокусом элементов актуальна только для клавиатурного ввода, поскольку события мыши
маршрутизируются в соответствии с z-order контролов, и фокус элементов при обработке событий мыши
не учитывается. Наоборот даже, как правило, события мыши приводят к изменению фокусного элемента.

Устроено все следующим образом. Каждый контрол может быть Focused = true, это означает, что он
имеет логический фокус. Но только один контрол из всех тех, кто обладает логическим фокусом, обладает еще и
клавиатурным фокусом (реальным фокусом ввода, куда направляются события ввода с клавиатуры).
Например, активное окно, внутри - панель с текстбоксом. Все элементы - окно, панель и текстбокс - имеют
логический фокус, но только текстбокс обладает клавиатурным фокусом. Если активное окно поменяется, то
логический фокус панели и текстбокса останутся, чтобы при повторной активизации окна автоматически вернуться
к состоянию фокуса, которое было до деактивизации окна.

Хранится состояние фокуса дерева элементов в самих контролах - свойство Focused и public-accessor к нему
HasLogicalFocus. А элемент, который обладает клавиатурным фокусом, хранится в FocusManager - FocusedElement.

Чтобы поддерживать состояние дерева корректным, необходимо при добавлении/удалении элементов и поддеревьев
выполнять соответствующие операции, чтобы не было ситуаций, когда FocusedElement указывает на удаленный из
визуального дерева контрол, или если к FocusedElement добавили поддерево элементов, а фокус остался на
старом FocusedElement вместо того, чтобы распространиться вниз. FocusManager предоставляет обработчики
AfterAdd и BeforeRemove, которые Control вызывает автоматически при изменении дерева визуальных элементов.

Это первый путь для смены фокусного элемента. Ну и второй путь - вызов SetFocus у контрола, который
делегируется FocusManager'у. Явно пытается установить фокус на выбранный контрол. Если все ок (контрол вместе
с родителями является Focusable, Visible) то посылается пара Preview-событий PreviewLostKeyboardFocus и
PreviewGotKeyboardFocus. Если при обработке этих routed events Handled будет установлен в true, то операция
SetFocus отменяется, и состояние фокуса возвращается к исходному. Если же отменять операцию не нужно,
FocusedElement будет изменен и будут посланы 2 события LostKeyboardFocus и GotKeyboardFocus.

TODO : Придумать, как задавать фокусный элемент перед добавлением поддерева визуальных элементов
(чтобы до вызова Application.Run() задать контрол, который получит фокус ввода).