У элемента управления перед рендерингом должны быть известны следующие компоненты:

1. Слот, в котором размещается графическое представление. Представлен свойством RenderSlotRect -
   rectangle относительно холста родительского элемента. Выставляется при вызове Arrange(Rect finalSize)
   собственно этому finalSize и равен.
2. Размеры виртуального холста, в которое будет отрисован элемент управления.
   Заданы свойством RenderSize, которое определяется при ревалидации Arrange-фазы.
   Виртуальный холст может быть больше или меньше слота.
3. Инфа о том, как расположить виртуальный холст в слот, в рамках которого необходимо остаться.
   Если размеры виртуального холста превышают размеры слота, отведенного для элемента управления, то
   часть виртуального холста будет обрезана. Что именно будет обрезано - определяется комбинацией свойств
   HorizontalAlignment, VerticalAlignment и Margin.
   То есть по имеющимся свойствам RenderSlotRect, RenderSize и HorizontalAlignment, VerticalAlignment, Margin
   можно вычислить положение виртуального холста в слоте, предоставленном родительским элементом управления.
   А для рисования необходимо вычислить:
   а) Смещение виртуального холста относительно слота - свойство ActualOffset (может быть отрицательным)
   б) Прямоугольник, который бы отрезал лишнее из виртуального холста - эта штука появляется при заданном Margin.
      (LayoutClip).

Margin определяет то, насколько сдвинуто "изображение" контрола относительно его же виртуального холста.
Поэтому клиппинг может происходить в следующих местах:
1. При применении Margin к виртуальному холсту при рендеринге контрола в виртуальный буфер
2. При применении RenderSlotRect + ActualOffset - так мы узнаем, как разместить в виртуальном холста парента наш
   контрол.




Механизм обновления лайаута для конкретно взятого контрола:
1. Допустим, у него были установлены какие-то значения свойств, и допустим, что система лайаута уже вызывалась
	(положим, был вызван Measure+Arrange, но не был вызван Render)
2. Кто-то изменил значение одного из свойств, которое влияет на отрисовку контрола. Для упрощения пока не будем разделять
	разные типы side-эффектов (типа одно влияет только на Arrange, другое - на Measure+Arrange). Пока просто - необходимо
	ревалидировать лайаут контрола полностью.
3. Все просчитанное что было в контроле (DesiredSize, RenderSize, LastMeasureArg, RenderSlotRect(по сути LastArrangeArg),
	LayoutClip и ActualOffset) мы сохраняем в Last-values с пометкой о том, насколько валиден был лайаут для этого состояния контрола
	(в рассматриваемом случае - были валидны все свойства, поскольку и Measure, и Arrange отработали).
4. Помечаем контрол как требующий обновления лайаута.
5. Рендерер начинает апдейт и если при пересчете лайаута будет обнаружено, что какие-то свойства не изменились (например DesiredSize, RenderSize)
	то обновление будет оптимизировано в соответствии с логикой (к примеру, в некоторых случаях не нужно вызывать обновление лайаута дочерних контролов).


По поводу "приоритетности" значений, возвращаемых методом MeasureOverride и жестко установленных Width/Height.
Приоритетнее - то, что больше. То есть, если контрол затребовал 10 пикселей в ширину, а Width вы установили в 5,
то Width будет проигнорирован. Обратное тоже верно. Таким образом, контрол должен быть готов к тому, что его
ActualWidth и ActualHeight могут быть больше тех, которые он вернул в качестве Desired Size. Но меньше
требуемых они быть не могут. Если у родительского контрола не хватает места, то на ActualWidth и ActualHeight
это не повлияет - просто при рендеринге контрол будет обрезан.

Описание для разработчиков контролов и панелей.

MeasureOverride и ArrangeOverride - по аналогии с WPF, позволяют определить собственные размеры, а также
размеры и логику размещения дочерних элементов управления. Первый метод вызывается из метода Measure
класса Control и отвечает на следующий вопрос - "Вот у меня есть свободное место availableSize.
Скажи, сколько места тебе нужно для размещения вместе с твоими дочерними элементами?" и возвращает
UnclippedDesiredSize. Этот возвращаемый размер может быть равен availableSize, а может быть больше или меньше его.
Если он превышает availableSize, то Measure запомнит это, но DesiredSize установит = availableSize.

ArrangeOverride принимает finalSize - размер слота, который родительский элемент выделил этому контролу.
Слот уже не будет изменён, и теперь задача нашего контрола (или панели) - занять выделенное пространство.
Обычный контрол просто занимает некую часть этого слота и возвращает размер реально используемого пространства
Как правило, возвращается тот же finalSize, но можно вернуть как бОльший размер, так и меньший.
В случае, если возвращаемое значение больше переданного finalSize - рендеринг контрола будет обрезан.
Если же возвращаемое значение меньше переданного finalSize - контрол займет лишь часть площади слота.
Панель же в дополнение к этому должна разместить дочерние элементы вызовами Arrange(finalRect).
Итак, finalSize - это размер слота (RenderSlotRect), а возвращаемое значение становится размерами
виртуального буфера контрола, куда будет производиться рендеринг (RenderSize и соответственно ActualWidth, ActualHeight).

